import React, { Component, } from 'react';
import PropTypes from 'prop-types';
import { attrsPropType, } from '../../propTypes/attrsPropType';
import Note from '../Note/Note';
import RadioButton from './RadioButton'; // eslint-disable-line import/no-named-as-default
import { radioButtonPropType, } from './RadioButtonPropType';

class RadioGroup extends Component {
  static propTypes = {
    /**
     * An object of attrbutes to set on the DOM element.
     * Passed to the underlying ul element wrapping the radioButtons
     */
    attrs: attrsPropType,

    /** Class(es) to be added to the ul DOM element.
     * Automatically generated by Fela, do not enter manually.
     */
    className: PropTypes.string,
    /**
     * The default value of an uncontrolled RadioGroup, should not be passed if the radio group is controlled
     */
    defaultValue: PropTypes.string,
    /** error note to display if input is passed a `isError` prop */
    errorText: PropTypes.string,
    /** Is this RadioGroup in error state */
    isError: PropTypes.bool,
    /**
     * The name attribute of the `RadioGroup`, passed to each of The `RadioButton`s
     * rendered by the component.
     */
    name: PropTypes.string.isRequired,
    /**
     * Id used to connect the note to `RadioGroup` with aria-describedby for a11y reasons,
     * default will generate random id
     */
    noteId: PropTypes.string,
    /** Note explaining the RadioGroup field  */
    noteText: PropTypes.string,
    /**
     * A callback that gets called when a RadioButton is Blurred
     * @param {SyntheticEvent} evt - The event object
     */
    onBlur: PropTypes.func,
    /**
     * A callback that gets the event that holds new value of the checked `RadioButton`
     * used to update state of parent when using as react controlled radioButton
     * @param {SyntheticEvent} evt - The event object
     */
    onChange: PropTypes.func,
    /**
     * A callback that gets called when a `RadioButton` is focused
     * @param {SyntheticEvent} evt - The event object
     */
    onFocus: PropTypes.func,
    /**
     * An Array of objects with props to pass to each RadioButton,
     *
     * The value of each radioButton is required for the RadioGroup to work properly
     * The following props should not be passed both to a RadioButton and to the RadioGroup
     * refFunc, onChange, onFocus, onBlur
     *
     * name, and checked shoud not be passed manually to a RadioButton
     */
    radioButtons: PropTypes.arrayOf(PropTypes.shape(radioButtonPropType))
      .isRequired,
    /**
     * The refFunc is passed to the first RadioButton
     * A callback function to allow parent component to get ref of input,
     * example use case: focusing the input.
     */
    refFunc: PropTypes.func,
    /**
     * The value of the selected `RadioButton`, null if no value is passed
     * Used to use `RadioGroup` as a Controlled component.
     */
    value: PropTypes.string,
  };

  static defaultProps = {
    attrs: null,
    className: null,
    defaultValue: null,
    errorText: null,
    isError: false,
    noteId: null,
    noteText: null,
    onBlur: null,
    onChange: null,
    onFocus: null,
    refFunc: null,
    value: null,
  };
  state = {
    noteId: this.props.noteId
      ? this.props.noteId
      : this.props.errorText || this.props.noteText
        ? Math.random().toString()
        : null,
    ...(this.props.value === null ? { value: this.props.defaultValue, } : {}),
  };

  handleChange = evt => {
    this.setState({ value: evt.target.value, });
    this.props.onChange && this.props.onChange(evt);
  };

  render() {
    const {
      attrs,
      className,
      errorText,
      isError,
      name,
      noteText,
      onBlur,
      onFocus,
      radioButtons,
      refFunc,
      value,
    } = this.props;

    const controllingValue = value !== null ? value : this.state.value;
    return (
      <div>
        <ul className={className} {...attrs}>
          {radioButtons.map((radioButton, idx) => (
            <li key={name + radioButton.value}>
              <RadioButton
                // radioButton is spread first so controlling attrs will run over attrs passed through props
                {...radioButton}
                checked={controllingValue === radioButton.value}
                name={name}
                {...(idx === 0 ? { refFunc, } : {})}
                onChange={this.handleChange}
                onBlur={onBlur}
                onFocus={onFocus}
              />
            </li>
          ))}
        </ul>
        {errorText || noteText ? (
          <Note
            text={isError ? errorText : noteText}
            isError={isError}
            noteId={this.state.noteId}
          />
        ) : null}
      </div>
    );
  }
}

export default RadioGroup;
