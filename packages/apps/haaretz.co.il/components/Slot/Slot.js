import React from 'react';
import PropTypes from 'prop-types';
import { connect, } from 'react-fela';
import dynamic from 'next/dynamic';
import gql from 'graphql-tag';

import CommentsElement from '../Comments/Comments';
// const CommentsElement = dynamic(import ('../Comments/Comments'));
const StandardArticle = dynamic(import('../StandardArticle/StandardArticle'));

const propTypes = {
  /**
   * The name of the slot, e.g. `header`, `footer`, `main`.
   */
  name: PropTypes.string.isRequired,
  /**
   * An array of content element data that should be rendered in the slot.
   */
  content: PropTypes.arrayOf(
    PropTypes.shape({
      contentId: PropTypes.string.isRequired,
      contentName: PropTypes.string,
      inputTemplate: PropTypes.string,
      properties: PropTypes.object.isRequired,
    })
  ).isRequired,
  pageContentId: PropTypes.string.isRequired,
  /**
   * An object whose keys map to `className` values generated by Fela.
   */
  styles: PropTypes.shape({
    container: PropTypes.string,
    separator: PropTypes.string,
    link: PropTypes.string,
  }).isRequired,
};

const fragments = {
  content: gql`
    fragment SlotContent on Slot {
      name
      content {
        contentId
        contentName
        inputTemplate
        properties
      }
    }
  `,
};

const rules = {
  container: props => ({ border: '1px solid #bbb', margin: 0.25, padding: 0.25, }),
  content: props => ({ border: '1px solid #ddd', margin: 0.25, padding: 0.25, }),
};

export function Slot({ name, content, styles, pageContentId, }) {
  const mapper = (element, i) => {
    let jsx;
    switch (element.inputTemplate) {
      case 'com.htz.StandardArticle':
        jsx = <StandardArticle {...element} {...element.properties} />;
        break;
      case 'com.tm.CommentsElement':
        // jsx = <CommentsElement contentId={element.contentId}/>;
        console.warn(pageContentId);
        jsx = <CommentsElement contentId={element.contentId} articleId={pageContentId} />;
        break;
      default:
        jsx = (
          <dl>
            <dt>contentId</dt>
            <dd>{element.contentId}</dd>
            <dt>contentName</dt>
            <dd>{element.contentName}</dd>
            <dt>inputTemplate</dt>
            <dd>{element.inputTemplate}</dd>
            <dt>properties</dt>
            {Object.keys(element.properties)
              .sort()
              .map(key => <dd key={key}>{key}</dd>)}
          </dl>
        );
    }

    return (
      <div // There can indeed be duplicate content elements in the returned
        // list, so we have no choice but to add an extra key identifier like
        // the index.
        // eslint-disable-next-line react/no-array-index-key
        key={`${element.contentId}:${i}`}
        className={styles.content}
      >
        {jsx}
      </div>
    );
  };

  // Placeholder output, useful for debugging.
  return (
    <div className={styles.container}>
      <h2>Slot: {name}</h2>
      {content.map((element, i) => mapper(element, i))}
    </div>
  );
}

Slot.propTypes = propTypes;

const StyledSlot = connect(rules)(Slot);
StyledSlot.fragments = fragments;

export default StyledSlot;
